#!/usr/bin/env node
/**
 * ðŸ¤– Smart Contract Security Bot
 * 
 * Automatically discovers GitHub repositories with smart contracts,
 * scans for security issues, and generates draft PRs with improvements.
 * 
 * Safety: DRY_RUN=true by default, no destructive operations without opt-in
 */

const { Octokit } = require('@octokit/rest');
const fs = require('fs');
const path = require('path');

// Configuration from environment
const config = {
  dryRun: process.env.DRY_RUN !== 'false',
  botPingsEnabled: process.env.BOT_PINGS_ENABLED === 'true',
  allowlistOrgs: process.env.ALLOWLIST_ORGS ? process.env.ALLOWLIST_ORGS.split(',').map(s => s.trim()) : [],
  maxPrsPerRun: parseInt(process.env.MAX_PRS_PER_RUN || '3', 10),
  starThreshold: parseInt(process.env.STAR_THRESHOLD || '10', 10),
  searchKeywords: process.env.SEARCH_KEYWORDS || 'smart contract solidity rust',
  ghToken: process.env.GH_TOKEN || process.env.GITHUB_TOKEN || '',
};

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

// Logging helpers
const log = {
  info: (msg) => console.log(`${colors.blue}[INFO]${colors.reset} ${msg}`),
  success: (msg) => console.log(`${colors.green}[SUCCESS]${colors.reset} ${msg}`),
  warn: (msg) => console.log(`${colors.yellow}[WARN]${colors.reset} ${msg}`),
  error: (msg) => console.error(`${colors.red}[ERROR]${colors.reset} ${msg}`),
  debug: (msg) => console.log(`${colors.cyan}[DEBUG]${colors.reset} ${msg}`),
};

// Banner
function showBanner() {
  console.log(`${colors.magenta}
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ðŸ¤– Smart Contract Security Bot                          â•‘
â•‘  GitAntivirus - Automated Repository Scanning            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${colors.reset}`);
}

// Initialize Octokit
let octokit;
if (config.ghToken) {
  octokit = new Octokit({ auth: config.ghToken });
  log.success('GitHub token found (authenticated mode)');
} else {
  octokit = new Octokit();
  log.warn('No GitHub token found (unauthenticated mode, rate limits apply)');
  log.info('Set GH_TOKEN or GITHUB_TOKEN environment variable for authenticated access');
}

// Load PR template
function loadPRTemplate() {
  const templatePath = path.join(__dirname, '..', 'PR_TEMPLATE.md');
  try {
    if (fs.existsSync(templatePath)) {
      return fs.readFileSync(templatePath, 'utf8');
    }
  } catch (error) {
    log.warn(`Could not load PR template: ${error.message}`);
  }
  
  // Fallback template
  return `## ðŸ” Security Improvements

This automated PR adds security enhancements and GitAntivirus integration.

### âœ… Safety Checklist
- [ ] DRY_RUN enabled by default
- [ ] No secrets in code
- [ ] Bot pings are opt-in
- [ ] Draft PR (no auto-merge)

### ðŸ“Š Evidence
- Scanned by SmartBrain orchestrator
- Security patterns validated
- Configuration reviewed

---
*Generated by SmartContractAudit bot - Review carefully before merging*
`;
}

// Search GitHub for repositories
async function searchRepositories() {
  log.info(`Searching GitHub for: "${config.searchKeywords}"`);
  
  try {
    const response = await octokit.rest.search.repos({
      q: config.searchKeywords,
      sort: 'stars',
      order: 'desc',
      per_page: 30,
    });
    
    log.success(`Found ${response.data.items.length} repositories`);
    return response.data.items;
  } catch (error) {
    log.error(`Search failed: ${error.message}`);
    return [];
  }
}

// Filter repositories by criteria
function filterRepositories(repos) {
  log.info('Filtering repositories...');
  
  const filtered = repos.filter(repo => {
    // Check star threshold
    if (repo.stargazers_count < config.starThreshold) {
      log.debug(`Filtered out ${repo.full_name}: below star threshold (${repo.stargazers_count} < ${config.starThreshold})`);
      return false;
    }
    
    // Check allowlist if configured
    if (config.allowlistOrgs.length > 0) {
      if (!config.allowlistOrgs.includes(repo.owner.login)) {
        log.debug(`Filtered out ${repo.full_name}: not in allowlist`);
        return false;
      }
    }
    
    // Check if archived
    if (repo.archived) {
      log.debug(`Filtered out ${repo.full_name}: archived`);
      return false;
    }
    
    log.success(`âœ… ${repo.full_name} matches criteria (â­ ${repo.stargazers_count})`);
    return true;
  });
  
  log.info(`${filtered.length} repositories match criteria`);
  return filtered;
}

// Prepare PR body with conditional pings
function preparePRBody(repo, template) {
  let body = template;
  
  // Add repository-specific information
  body += `\n\n### ðŸ“¦ Repository Information\n`;
  body += `- **Name:** ${repo.full_name}\n`;
  body += `- **Stars:** â­ ${repo.stargazers_count}\n`;
  body += `- **Language:** ${repo.language || 'Multiple'}\n`;
  
  // Conditional ping: only if BOT_PINGS_ENABLED=true AND owner is SolanaRemix
  if (config.botPingsEnabled && repo.owner.login === 'SolanaRemix') {
    body += `\n\nðŸ“¢ cc: @SolanaRemix\n`;
  }
  
  return body;
}

// Create draft PR (or simulate in dry-run)
async function createPR(repo) {
  const prTitle = 'ðŸ” Add GitAntivirus security scanning';
  const prBody = preparePRBody(repo, loadPRTemplate());
  
  if (config.dryRun) {
    log.info(`[DRY-RUN] Would create PR on ${repo.full_name}`);
    log.debug(`Title: ${prTitle}`);
    log.debug(`Body preview: ${prBody.substring(0, 100)}...`);
    return { simulated: true, repo: repo.full_name };
  }
  
  if (!config.ghToken) {
    log.error(`Cannot create PR without GitHub token`);
    return { error: 'No token provided' };
  }
  
  try {
    log.info(`Creating draft PR on ${repo.full_name}...`);
    
    // In a real implementation, you would:
    // 1. Fork the repository (if needed)
    // 2. Create a branch
    // 3. Add GitAntivirus files
    // 4. Commit changes
    // 5. Create PR
    
    // For this template, we just log the intent
    log.warn('PR creation not fully implemented (template mode)');
    log.info('To implement: fork repo, add files, commit, create PR via Octokit');
    
    return { created: false, reason: 'Template mode' };
  } catch (error) {
    log.error(`Failed to create PR: ${error.message}`);
    return { error: error.message };
  }
}

// Save summary to logs
function saveSummary(summary) {
  const logsDir = path.join(__dirname, '..', 'logs');
  const summaryPath = path.join(logsDir, 'summary.json');
  
  try {
    // Ensure logs directory exists
    if (!fs.existsSync(logsDir)) {
      fs.mkdirSync(logsDir, { recursive: true });
    }
    
    fs.writeFileSync(summaryPath, JSON.stringify(summary, null, 2));
    log.success(`Summary saved to ${summaryPath}`);
  } catch (error) {
    log.error(`Could not save summary: ${error.message}`);
  }
}

// Main execution
async function main() {
  showBanner();
  
  log.info('Configuration:');
  log.info(`  DRY_RUN: ${config.dryRun}`);
  log.info(`  BOT_PINGS_ENABLED: ${config.botPingsEnabled}`);
  log.info(`  ALLOWLIST_ORGS: ${config.allowlistOrgs.join(', ') || '(none - all orgs)'}`);
  log.info(`  MAX_PRS_PER_RUN: ${config.maxPrsPerRun}`);
  log.info(`  STAR_THRESHOLD: ${config.starThreshold}`);
  log.info(`  SEARCH_KEYWORDS: "${config.searchKeywords}"`);
  
  if (config.dryRun) {
    log.warn('ðŸ”’ Running in DRY-RUN mode - no PRs will be created');
  } else {
    log.warn('ðŸš€ Running in LIVE mode - PRs will be created!');
  }
  
  // Search for repositories
  const repos = await searchRepositories();
  
  if (repos.length === 0) {
    log.warn('No repositories found. Try different search keywords.');
    return;
  }
  
  // Filter repositories
  const filtered = filterRepositories(repos);
  
  if (filtered.length === 0) {
    log.warn('No repositories match the filter criteria.');
    return;
  }
  
  // Process repositories (up to max limit)
  const toProcess = filtered.slice(0, config.maxPrsPerRun);
  log.info(`Processing ${toProcess.length} repositories (max: ${config.maxPrsPerRun})`);
  
  const results = [];
  for (const repo of toProcess) {
    const result = await createPR(repo);
    results.push({ repo: repo.full_name, result });
  }
  
  // Summary
  const summary = {
    timestamp: new Date().toISOString(),
    dry_run: config.dryRun,
    bot_pings_enabled: config.botPingsEnabled,
    repos_scanned: repos.length,
    repos_matched: filtered.length,
    prs_created: config.dryRun ? 0 : results.filter(r => r.result.created).length,
    prs_would_create: config.dryRun ? toProcess.length : 0,
    allowlist_orgs: config.allowlistOrgs,
    max_prs_per_run: config.maxPrsPerRun,
    results,
  };
  
  // Conditional ping in summary (only for SolanaRemix)
  if (config.botPingsEnabled) {
    const solanaRemixRepos = toProcess.filter(r => r.owner.login === 'SolanaRemix');
    if (solanaRemixRepos.length > 0) {
      summary.ping = '@SolanaRemix';
      log.info('Summary includes ping for SolanaRemix repos');
    }
  }
  
  saveSummary(summary);
  
  log.success('Bot execution complete! ðŸŽ‰');
  log.info(`Summary: ${summary.repos_matched} repos matched, ${config.dryRun ? 'would create' : 'created'} ${toProcess.length} PRs`);
}

// Run main
if (require.main === module) {
  main().catch(error => {
    log.error(`Fatal error: ${error.message}`);
    console.error(error);
    process.exit(1);
  });
}

module.exports = { main };
